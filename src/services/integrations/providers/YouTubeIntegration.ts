import { BaseIntegration } from '../base/BaseIntegration';
import { 
  IntegrationCapabilities, 
  ImportResult, 
  ExportOptions, 
  YouTubeTranscript,
  BaseIntegration as IBaseIntegration
} from '../types';

// Types will be imported from the main app
type Item = any;
type ItemType = 'todo' | 'note' | 'event' | 'goal' | 'routine';

export class YouTubeIntegration extends BaseIntegration {
  private readonly youtubeApiUrl = 'https://www.googleapis.com/youtube/v3';

  constructor(config: IBaseIntegration) {
    super(config);
  }

  getCapabilities(): IntegrationCapabilities {
    return {
      canImport: true,
      canExport: false,
      canSync: false,
      supportsRealtime: false,
      supportedItemTypes: ['notes'],
      maxBatchSize: 50,
      rateLimits: {
        requestsPerMinute: 100,
        requestsPerHour: 10000,
        requestsPerDay: 1000000
      }
    };
  }

  async authenticate(): Promise<void> {
    if (!this.accessToken) {
      throw this.createError('NO_TOKEN', 'YouTube API key is required');
    }

    const isValid = await this.testConnection();
    if (!isValid) {
      throw this.createError('INVALID_TOKEN', 'Invalid YouTube API key');
    }

    this.setStatus('connected');
  }

  async refreshAccessToken(): Promise<void> {
    // YouTube API keys don't expire, just test validity
    const isValid = await this.testConnection();
    if (!isValid) {
      this.setStatus('error');
      throw this.createError('TOKEN_INVALID', 'YouTube API key is no longer valid');
    }
  }

  async testConnection(): Promise<boolean> {
    try {
      await this.makeRequest<any>(`${this.youtubeApiUrl}/search?part=snippet&maxResults=1&key=${this.accessToken}`);
      return true;
    } catch (error) {
      console.error('YouTube connection test failed:', error);
      return false;
    }
  }

  async importData(categoryId?: string): Promise<ImportResult> {
    // YouTube integration doesn't import in bulk, it's used for individual video transcripts
    return {
      provider: 'youtube',
      totalItems: 0,
      importedItems: 0,
      failedItems: 0,
      errors: ['YouTube integration is used for individual video transcript imports'],
      summary: {
        notes: 0
      }
    };
  }

  async exportData(options: ExportOptions): Promise<void> {
    throw new Error('Export to YouTube not supported');
  }

  // YouTube-specific methods
  async getVideoTranscript(videoUrl: string): Promise<YouTubeTranscript> {
    const videoId = this.extractVideoId(videoUrl);
    if (!videoId) {
      throw this.createError('INVALID_URL', 'Invalid YouTube video URL');
    }

    try {
      // Get video metadata
      const videoData = await this.getVideoMetadata(videoId);
      
      // Get transcript using multiple methods
      let transcript: Array<{ text: string; start: number; duration: number }> = [];
      
      try {
        // Try to get official transcript first
        transcript = await this.getOfficialTranscript(videoId);
      } catch (error) {
        try {
          // Fallback to auto-generated captions
          transcript = await this.getAutoGeneratedCaptions(videoId);
        } catch (captionError) {
          // Fallback to third-party transcript extraction
          transcript = await this.getTranscriptFromThirdParty(videoId);
        }
      }

      return {
        videoId,
        title: videoData.title,
        description: videoData.description,
        duration: this.parseDuration(videoData.duration),
        author: videoData.channelTitle,
        transcript,
        metadata: {
          publishedAt: videoData.publishedAt,
          viewCount: parseInt(videoData.viewCount || '0'),
          language: 'en' // Default, would need detection
        }
      };
    } catch (error) {
      throw this.createError(
        'TRANSCRIPT_FAILED',
        `Failed to get YouTube transcript: ${error instanceof Error ? error.message : 'Unknown error'}`
      );
    }
  }

  async importVideoTranscript(videoUrl: string, categoryId?: string): Promise<Item> {
    const transcriptData = await this.getVideoTranscript(videoUrl);
    
    // Convert transcript to readable format
    const transcriptText = transcriptData.transcript
      .map(segment => segment.text)
      .join(' ')
      .replace(/\s+/g, ' ')
      .trim();

    // Create structured content
    const content = this.formatTranscriptContent(transcriptData, transcriptText);

    const item = {
      id: `youtube-${transcriptData.videoId}`,
      type: 'note' as ItemType,
      title: `YouTube: ${transcriptData.title}`,
      description: transcriptData.description || '',
      content,
      categoryId: categoryId || 'imported-youtube',
      tags: ['youtube', 'transcript', 'video'],
      metadata: {
        source: 'youtube',
        originalId: transcriptData.videoId,
        videoUrl: `https://www.youtube.com/watch?v=${transcriptData.videoId}`,
        author: transcriptData.author,
        duration: transcriptData.duration,
        publishedAt: transcriptData.metadata.publishedAt,
        viewCount: transcriptData.metadata.viewCount
      },
      createdAt: new Date(),
      updatedAt: new Date()
    } as Item;

    return item;
  }

  private extractVideoId(url: string): string | null {
    const regex = /(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)([^&\n?#]+)/;
    const match = url.match(regex);
    return match ? match[1] : null;
  }

  private async getVideoMetadata(videoId: string): Promise<any> {
    const response = await this.makeRequest<{ items: any[] }>(
      `${this.youtubeApiUrl}/videos?part=snippet,contentDetails,statistics&id=${videoId}&key=${this.accessToken}`
    );

    if (!response.items || response.items.length === 0) {
      throw new Error('Video not found');
    }

    const video = response.items[0];
    return {
      title: video.snippet.title,
      description: video.snippet.description,
      channelTitle: video.snippet.channelTitle,
      publishedAt: video.snippet.publishedAt,
      duration: video.contentDetails.duration,
      viewCount: video.statistics.viewCount
    };
  }

  private async getOfficialTranscript(videoId: string): Promise<Array<{ text: string; start: number; duration: number }>> {
    // This would require YouTube Data API v3 captions endpoint
    // Note: This requires OAuth and specific permissions
    const response = await this.makeRequest<{ items: any[] }>(
      `${this.youtubeApiUrl}/captions?part=snippet&videoId=${videoId}&key=${this.accessToken}`
    );

    if (!response.items || response.items.length === 0) {
      throw new Error('No captions available');
    }

    // Get the first English caption track
    const captionTrack = response.items.find(item => 
      item.snippet.language === 'en' || item.snippet.language === 'en-US'
    ) || response.items[0];

    // Download caption content (this requires OAuth)
    const captionContent = await this.makeRequest<string>(
      `${this.youtubeApiUrl}/captions/${captionTrack.id}?key=${this.accessToken}`
    );

    return this.parseCaptionContent(captionContent);
  }

  private async getAutoGeneratedCaptions(videoId: string): Promise<Array<{ text: string; start: number; duration: number }>> {
    // Fallback method using auto-generated captions
    // This is a simplified implementation
    throw new Error('Auto-generated captions not implemented');
  }

  private async getTranscriptFromThirdParty(videoId: string): Promise<Array<{ text: string; start: number; duration: number }>> {
    // Use the youtube-transcript-api library approach
    try {
      // This would use a service like the one we researched
      const response = await fetch(`https://youtube-transcript-api.onrender.com/transcript/${videoId}`);
      
      if (!response.ok) {
        throw new Error('Third-party transcript service failed');
      }

      const data = await response.json();
      
      return data.transcript?.map((item: any) => ({
        text: item.text,
        start: parseFloat(item.start),
        duration: parseFloat(item.dur || '0')
      })) || [];
    } catch (error) {
      throw new Error('No transcript available for this video');
    }
  }

  private parseCaptionContent(content: string): Array<{ text: string; start: number; duration: number }> {
    // Parse WebVTT or other caption formats
    // This is a simplified implementation
    const lines = content.split('\n');
    const segments: Array<{ text: string; start: number; duration: number }> = [];
    
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim();
      
      // Look for timestamp lines (WebVTT format)
      if (line.includes('-->')) {
        const [startTime, endTime] = line.split(' --> ');
        const start = this.parseTimestamp(startTime);
        const end = this.parseTimestamp(endTime);
        const duration = end - start;
        
        // Next line should be the text
        if (i + 1 < lines.length) {
          const text = lines[i + 1].trim();
          if (text) {
            segments.push({ text, start, duration });
          }
        }
      }
    }
    
    return segments;
  }

  private parseTimestamp(timestamp: string): number {
    // Parse timestamp like "00:01:23.456" to seconds
    const parts = timestamp.split(':');
    const seconds = parseFloat(parts.pop() || '0');
    const minutes = parseInt(parts.pop() || '0');
    const hours = parseInt(parts.pop() || '0');
    
    return hours * 3600 + minutes * 60 + seconds;
  }

  private parseDuration(duration: string): number {
    // Parse ISO 8601 duration like "PT4M13S" to seconds
    const match = duration.match(/PT(?:(\d+)H)?(?:(\d+)M)?(?:(\d+)S)?/);
    if (!match) return 0;
    
    const hours = parseInt(match[1] || '0');
    const minutes = parseInt(match[2] || '0');
    const seconds = parseInt(match[3] || '0');
    
    return hours * 3600 + minutes * 60 + seconds;
  }

  private formatTranscriptContent(transcriptData: YouTubeTranscript, transcriptText: string): string {
    const sections = [
      `# ${transcriptData.title}`,
      '',
      `**Author:** ${transcriptData.author}`,
      `**Duration:** ${Math.floor(transcriptData.duration / 60)}:${(transcriptData.duration % 60).toString().padStart(2, '0')}`,
      `**Published:** ${new Date(transcriptData.metadata.publishedAt).toLocaleDateString()}`,
      `**Views:** ${transcriptData.metadata.viewCount?.toLocaleString() || 'Unknown'}`,
      '',
      '## Description',
      transcriptData.description || 'No description available.',
      '',
      '## Transcript',
      transcriptText,
      '',
      '## Timestamped Segments',
      ...transcriptData.transcript.map(segment => 
        `**${Math.floor(segment.start / 60)}:${(segment.start % 60).toFixed(0).padStart(2, '0')}** - ${segment.text}`
      )
    ];

    return sections.join('\n');
  }

  // Batch import multiple videos
  async importMultipleVideos(videoUrls: string[], categoryId?: string): Promise<ImportResult> {
    const results: Item[] = [];
    const errors: string[] = [];

    for (const url of videoUrls) {
      try {
        const item = await this.importVideoTranscript(url, categoryId);
        results.push(item);
      } catch (error) {
        errors.push(`Failed to import ${url}: ${error instanceof Error ? error.message : 'Unknown error'}`);
      }
    }

    return {
      provider: 'youtube',
      totalItems: videoUrls.length,
      importedItems: results.length,
      failedItems: videoUrls.length - results.length,
      errors,
      summary: {
        notes: results.length
      }
    };
  }

  // Search YouTube videos (requires OAuth for some features)
  async searchVideos(query: string, maxResults: number = 10): Promise<Array<{
    videoId: string;
    title: string;
    description: string;
    channelTitle: string;
    publishedAt: string;
    thumbnails: any;
  }>> {
    const response = await this.makeRequest<{ items: any[] }>(
      `${this.youtubeApiUrl}/search?part=snippet&q=${encodeURIComponent(query)}&type=video&maxResults=${maxResults}&key=${this.accessToken}`
    );

    return response.items.map(item => ({
      videoId: item.id.videoId,
      title: item.snippet.title,
      description: item.snippet.description,
      channelTitle: item.snippet.channelTitle,
      publishedAt: item.snippet.publishedAt,
      thumbnails: item.snippet.thumbnails
    }));
  }

  // Override auth headers for YouTube API
  protected getAuthHeaders(): Record<string, string> {
    // YouTube API uses key parameter instead of Authorization header for API key
    return {};
  }
} 